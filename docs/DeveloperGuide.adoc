= CelebManager - Developer Guide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/CS2103JAN2018-W14-B4/main/

By: `CS2103JAN2018-W14-B4`      Since: `Jun 2016`      Licence: `MIT`

== Overview

Whether you are a new developer or a long time contributor to the CelebManager Project,
this developer guide will serve as a helpful reference and source of "how-to" information
when contributing to this project. Included are guides on how to set-up the project locally,
an overview of the architecture and the different features present and how they are implemented.

== Setting up

=== Prerequisites

Before we get started on the setup, there are a few prerequisites to have a successful setup. They are,

. *JDK* +
Our programming language of choice is Java in this project. To be able to work with java,
you will need to have Java Development Kit (JDK) installed. You must install version `1.8.0_60` or later.
You can get the JDK from: +
http://www.oracle.com/technetwork/java/javase/downloads/index.html
+
[NOTE]
Having any Java 8 version is not enough. +
Some components of this app will not work +
with earlier versions of Java 8.
+

. *IntelliJ* IDE +
It is possible to setup without IntelliJ specifically and other IDEs might be used, but it is much simpler
to carry it out in IntelliJ. All the steps for setup from here on out will be specific to IntelliJ. We highly recommend
that you too use IntelliJ unless you have prior experience in working with gradle projects. You can get IntelliJ from: +
https://www.jetbrains.com/idea/
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Setting up the project in your computer

If you want to contribute to this project, you will need to work with a local copy of this project. To do so:

. Fork this repo, and clone the fork to your computer.
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first).
. Set up the correct JDK version for Gradle:
.. Click `Configure` > `Project Defaults` > `Project Structure`.
.. Click `New...` and find the directory of the JDK.
. Click `Import Project`.
. Locate the `build.gradle` file, select it and click `OK`.
. Click `Open as Project`.
. Click `OK` to accept the default settings.
. Open a console and run the command `gradlew processResources`. (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the setup

To ensure that you have setup the project correctly: +

. Run the `seedu.address.MainApp` and try a few commands.
. <<Testing,Run the tests>> to ensure they all pass.

=== Configurations to do before writing code

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.adoc[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify:

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS).
. Select `Editor` > `Code Style` > `Java`.
. Click on the `Imports` tab to set the order. Take note of the following:

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements.
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`.

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating documentation to match your fork

After forking the repo, links in the documentation will still point to the `CS2103JAN2018-W14-B4/main` repo. If you plan to develop this as a separate product (i.e. instead of contributing to the `CS2103JAN2018-W14-B4/main`) , you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

After setting up Travis, you can optionally set up coverage reporting for your team fork (see <<UsingCoveralls#, UsingCoveralls.adoc>>).

[NOTE]
Coverage reporting could be useful for a team repository that hosts the final version but it is not that useful for your personal fork.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

==== Getting started with coding

When you are ready to start coding:

1. Get some sense of the overall design by reading <<Design-Architecture>>.
2. Take a look at <<GetStartedProgramming>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::Architecture.png[width="600"]

The *_Architecture Diagram_* given above (Figure 1) explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.

`Main` has only one class called link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for the following:

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components. Two of those classes play important roles at the architecture level. These are:

* `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]) is used by components to communicate with other components using events (i.e. a form of _Event Driven_ design)
* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components. They are:

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components,

* defines its _API_ in an `interface` with the same name as the Component.
* exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see Figure 2) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[width="800"]

[discrete]
==== Events-Driven nature of the design

The _Sequence Diagram_ below (Figure 3) shows how the components interact for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command (part 1)
image::SDforDeletePerson.png[width="800"]

[NOTE]
Note how the `Model` simply raises a `AddressBookChangedEvent` when the Celeb Scheduler data is changed, instead of asking the `Storage` to save the updates to the hard disk.

The diagram below (Figure 4) shows how the `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

.Component interactions for `delete 1` command (part 2)
image::SDforDeletePersonEventHandling.png[width="800"]

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be coupled to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The sections below describe each component in greater detail.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

From the diagram above (Figure 5), we can see that the UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter`, `BrowserPanel` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* executes user commands using the `Logic` component.
* binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* responds to events raised from various parts of the App and updates the UI accordingly.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[width="800"]

.Structure of Commands in the Logic Component. This diagram shows finer details concerning `XYZCommand` and `Command` in <<fig-LogicClassDiagram>>
image::LogicCommandClassDiagram.png[width="800"]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

The diagrams above (Figures 6 & 7) describe the overall structure of the `Logic` component and
how a single command such as `XYZCommand` and other commands are structured respectively. When the user types
in a new command to be parsed, the following happen:

.  `Logic` uses the `AddressBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

Given below (Figure 8) is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeletePersonSdForLogic.png[width="800"]

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The diagram above (Figure 9) describes the overall structure of the `Model` component, along with all
its sub-components.

The `Model` component,

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* exposes an unmodifiable `ObservableList<Person>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The diagram above (Figure 10) describes how the overall structure of the `Storage` component and its different sub-components.

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Address Book data in xml format and read it back.
* can save the Appointment List data in xml format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::undoredo[]
=== Undo/Redo feature
==== Current Implementation

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports undoing and redoing of commands that modifies the state of the address book (e.g. `add`, `edit`). Such commands will inherit from `UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead. The following diagram shows the inheritance diagram for commands:

image::LogicCommandClassDiagram.png[width="800"]

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and concrete commands that can be undone, such as the `DeleteCommand`. Note that extra tasks need to be done when executing a command in an _undoable_ way, such as saving the state of the address book before execution. `UndoableCommand` contains the high-level algorithm for those extra tasks while the child classes implements the details of how to execute the specific command. Note that this technique of putting the high-level algorithm in the parent class and lower-level steps of the algorithm in child classes is also known as the https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern].

Commands that are not undoable are implemented this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

With the extra layer, the commands that are undoable are implemented this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

Suppose that the user has just launched the application. The `UndoRedoStack` will be empty at the beginning.

The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th person in the address book. The current state of the address book is saved before the `delete 5` command executes. The `delete 5` command will then be pushed onto the `undoStack` (the current state is saved together with the command).

image::UndoRedoStartingStackDiagram.png[width="800"]

As the user continues to use the program, more commands are added into the `undoStack`. For example, the user may execute `add n/David ...` to add a new person.

image::UndoRedoNewCommand1StackDiagram.png[width="800"]

[NOTE]
If a command fails its execution, it will not be pushed to the `UndoRedoStack` at all.

The user now decides that adding the person was a mistake, and decides to undo that action using `undo`.

We will pop the most recent command out of the `undoStack` and push it back to the `redoStack`. We will restore the address book to the state before the `add` command executed.

image::UndoRedoExecuteUndoStackDiagram.png[width="800"]

[NOTE]
If the `undoStack` is empty, then there are no other commands left to be undone, and an `Exception` will be thrown when popping the `undoStack`.

The following sequence diagram shows how the undo operation works:

image::UndoRedoSequenceDiagram.png[width="800"]

The redo does the exact opposite (pops from `redoStack`, push to `undoStack`, and restores the address book to the state after the command is executed).

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone, and an `Exception` will be thrown when popping the `redoStack`.

The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`. This time the `redoStack` is no longer empty. It will be purged as it no longer make sense to redo the `add n/David` command (this is the behavior that most modern desktop applications follow).

image::UndoRedoNewCommand2StackDiagram.png[width="800"]

Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution:

image::UndoRedoNewCommand3StackDiagram.png[width="800"]

The following activity diagram summarize what happens inside the `UndoRedoStack` when a user executes a new command:

image::UndoRedoActivityDiagram.png[width="650"]

==== Design Considerations

===== Aspect: Implementation of `UndoableCommand`

* **Alternative 1 (current choice):** Add a new abstract method `executeUndoableCommand()`
** Pros: We will not lose any undone/redone functionality as it is now part of the default behaviour. Classes that deal with `Command` do not have to know that `executeUndoableCommand()` exist.
** Cons: Hard for new developers to understand the template pattern.
* **Alternative 2:** Just override `execute()`
** Pros: Does not involve the template pattern, easier for new developers to understand.
** Cons: Classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to undo/redo.

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves the entire address book.
** Pros: Easy to implement.
** Cons: May have performance issues in terms of memory usage.
* **Alternative 2:** Individual command knows how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete`, just save the person being deleted).
** Cons: We must ensure that the implementation of each individual command are correct.


===== Aspect: Type of commands that can be undone/redone

* **Alternative 1 (current choice):** Only include commands that modifies the address book (`add`, `clear`, `edit`).
** Pros: We only revert changes that are hard to change back (the view can easily be re-modified as no data are * lost).
** Cons: User might think that undo also applies when the list is modified (undoing filtering for example), * only to realize that it does not do that, after executing `undo`.
* **Alternative 2:** Include all commands.
** Pros: Might be more intuitive for the user.
** Cons: User have no way of skipping such commands if he or she just want to reset the state of the address * book and not the view.
**Additional Info:** See our discussion  https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here].


===== Aspect: Data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use separate stack for undo and redo
** Pros: Easy to understand for new Computer Science student undergraduates to understand, who are likely to be * the new incoming developers of our project.
** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update * both `HistoryManager` and `UndoRedoStack`.
* **Alternative 2:** Use `HistoryManager` for undo/redo
** Pros: We do not need to maintain a separate stack, and just reuse what is already in the codebase.
** Cons: Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two * different things.
// end::undoredo[]

// tag::dataencryption[]
=== [Proposed] Data Encryption

_{Explain here how the data encryption feature will be implemented}_

// end::dataencryption[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).

// tag::removeTag[]
=== RemoveTag feature
==== Current Implementation

This RemoveTag mechanism is facilitated by `RemoveTagCommand` which resides inside `Logic` and `removeTag` which resides in `AddressBook`.
`RemoveTagCommand` removes a specified tag from each person in the address book, and prints out how many persons are affected by this removal.
The following diagram shows the inheritance diagram for `RemoveTagCommand`:

.Inheritance diagram for Command
image::RemoveTagCommandClassDiagram.png[width=""]

As you can see from the diagram, `RemoveTagCommand` inherits from the `UndoableCommand`.
Similar to the other undoable commands like `DeleteCommand`, it supports the undo/redo feature.

Unlike `DeleteCommand` that can raise `PersonNotFoundException` when the `index` of the `person` to be deleted does not exist,
`RemoveTagCommand` can remove a non-existing tag from the address book, but implicitly tell the user that the tag does not exist
by showing that, the number of persons affected by the removal is 0.

The snippet code below shows the implementation of `executeUndoableCommand` in `RemoveTagCommand`:

[source,java]
----
public class RemoveTagCommand extends UndoableCommand {
    ...
    public static final String MESSAGE_DELETE_TAG_SUCCESS = "Removed Tag %1$s and %2$s person(s) affected.";
    ...

    @Override
    public CommandResult executeUndoableCommand() {
        requireNonNull(tagToRemove);
        int numberOfAffectedPersons = model.removeTag(tagToRemove);
        return new CommandResult(String.format(MESSAGE_DELETE_TAG_SUCCESS, tagToRemove, numberOfAffectedPersons));
    }

    ...
}
----

The snippet code below shows the implementation of `removeTag` in `AddressBook`:

[source,java]
----
public class AddressBook {
    /**
     * Removes {@code tag} from all persons in this {@code AddressBook}.
     * @returns the number of {@code person}s with this {@code tag} removed.
     */
    public int removeTag(Tag tag) {
        int count = 0;
        for (Person person: persons) {
            if (person.removeTag(tag)) {
                count++;
            }
        }
        if (count > 0) {
            removeUnusedTags();
        }
        return count;
    }
    ...
}
----

Note that `removeUnusedTags` is called inside `removeTag` when there is at least one person affected by the removal.
This is because this operation removes the tag from each person with it, and thus after the operation, no person in the
address book should have the tag, and hence the unused tag should be removed from `tags` inside the address book.

Suppose the current address book has two types of tags, `friends` and `husband`.
The snippet below shows the state of `PersonListPanel`:

.Image of `PersonListPanel` before executing `removeTag friends`
image::BeforeRemoveTag.png[width=""]

After the successful execution of `removeTag friends`, `PersonListPanel` will be updated to the diagram below:

.Image of `PersonListPanel` after executing `removeTag friends`
image::AfterRemoveTag.png[width=""]

The following sequence diagram shows how the command works:

.Sequence diagram of removeTag command
image::RemoveTagSequenceDiagram.png[width=""]

==== Design Considerations

===== Aspect: Command result for removal of non-existing `tag`
* **Alternative 1 (current choice):** Output `tag` is removed and 0 person affected
** Pros: Easy to implement.
** Cons: Does not make it explicit to users that the `tag` being removed does not exist in the address book.
* **Alternative 2:** Output the `tag` cannot be removed
** Pros: Makes it clear to users that the `tag` does not exist and thus cannot be removed.
** Cons: Does not invalidate the removal and can thus be confusing to users whether this removal is legal.
* **Alternative 3:** Output error and invalid command format
** Pros: Follows the common logical convention and makes it clear to users that the removal is not legal.
** Cons: Requires the creation of additional exception class and exception handling methods.

// tag::showlocation[]
=== ShowLocation Feature
==== Current Implementation

The ShowLocation mechanism is facilitated by the `ShowLocationCommand`, which resides inside `Logic`. It supports the viewing of location
in the `MapPanel` UI by updating the state of the `MapPanel`. This is done by re-centering the `MapPanel` to the latitude and longitude of the
location and identifying it with a location marker. This command inherits from `Command` so it *does not support the undo/redo feature*.

The following picture shows the marker that is used to identify the location in the `MapPanel`:

.Location Marker
image::LocationMarker.png[width="50"]

[.underline]*Inheritance of command*

The following diagram shows the inheritance diagram for `ShowLocationCommand`:

.Inheritance diagram for Command
image::ShowLocationLogicCommandClassDiagram.png[width=""]

As you can see from the diagram, `ShowLocationCommand` inherits from the Command class and is not part of the Undoable Command.
Similar to the other commands like `FindCommand` it will not be identified by the undo/redo feature.

[.underline]*Use of model*

This command does not use the `Person` `Address` model to search for a specific location, it uses the `MapAddress` model. This is due to the difference in address specification details as the `Address` model is too specific for the command to work.
An example would be the details of unit number (e.g #11-111) which will not be valid for this command.


The main difference between both model is shown below in the two diagrams.

The snippet code below shows the diagram of `Address` model:

[source,java]
----
public class Address {
    public static final String MESSAGE_ADDRESS_CONSTRAINTS =
                "Person addresses can take any values, and it should not be blank";
    /*
     * The first character of the address must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String ADDRESS_VALIDATION_REGEX = "[^\\s].*";
    /**
     * Returns true if a given string is a valid person email.
     */
    public static boolean isValidAddress(String test) {
        return test.matches(ADDRESS_VALIDATION_REGEX);
    }
    ...
}
----


The snippet code below shows the diagram of `MapAddress` model:

[source,java]
----
public class MapAddress {
    public static final String MESSAGE_ADDRESS_MAP_CONSTRAINTS =
            "Address should be in location name, road name, block and road name or postal code format.\n"
                    + "Note:(Person address may not be valid as it consist of too many details like unit number)"
    /*
     * The first character of the address must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String ADDRESS_VALIDATION_REGEX = "[^\\s].*";
    ...
    /**
     * Returns true if a given string is a valid map address.
     */
    public static boolean isValidAddress(String test) {
        boolean isValid;
        Geocoding testAddress = new Geocoding();
        isValid = testAddress.checkIfAddressCanBeFound(test);
        return test.matches(ADDRESS_MAP_VALIDATION_REGEX) && isValid;
    }
    ...
}
----
The difference to note is the `isValidAddress` method, where `Address` only checks for *blank space* whereas `MapAddress`
checks for *blank space and the validity of location in google server*. Thus, making the command more restrictive to location,
 road, block name and postal code. Any details more than that would result in a higher possibility of it being invalid.

[.underline]*Library used*

This command uses the `GMAPSFX API` and  `Google Maps Web Services API` library. The `GMAPFX API` is used to create the
`Geocoding` function, which is used to convert `MapAddress` into latitude and longitude form (`LatLng`). The `LatLng` form
is then used by the command to find the exact location in the `MapPanel`. The `Google Maps Web Services API` allows the
command to re-center and mark the new location which is then shown to the user.

[.underline]*Visual changes*

Every new input of this command will remove the previous location marker and add the new marker into the map.

The snippet below shows the state of `MapPanel` before input of `ShowLocation` command:

.Image of Map Panel default state
image::BeforeInput.png[width="400"]

After the input of "showLocation ma/Punggol" the `MapPanel` will be updated to the diagram below:

.Image of Map Panel after command input
image::AfterShowLocationInput.png[width="400"]

Any subsequent inputs will remove the previous location marker and update the `MapPanel` with the new marker.

[.underline]*Sequence of events*

The following sequence diagram shows how the command works:

.Sequence diagram of showLocation command
image::ShowLocationSequenceDiagram.png[width=""]

==== Design Considerations

===== Aspect: Implementation of `showLocationCommand`
* **Alternative 1 (current choice):** Extend `Command`
** Pros: Easy to understand for new developers who will be developing this project as the command is at the same abstraction level as other commands.
** Cons: Does not have the undo/redo feature as it is not part of `UndoableCommand`.
* **Alternative 2:** Extend `UndoableCommand`
** Pros: Allows for command to have the undo/redo function.
** Cons: Requires more work that may not fit in with our timeline.

===== Aspect: Use of address model
* **Alternative 1 (current choice):** Use `MapAddress`
** Pros: Allows the clear distinction of requirements between `MapAddress` and `Address` to avoid confusion.
** Cons: Both model are very similar.
* **Alternative 2:** Use `Address`
** Pros: Reduces the amount of code/class in the project.
** Cons: Will be confusing as different requirements for a single model. Lacks proper organisation.

=== AddAppointment feature
==== Current Implementation

The AddAppointment mechanism is facilitated by the `AddAppointmentCommand`, which resides inside `Logic`. It supports the adding of an appointment to an existing calendar.
The appointment, if added successfully, can be viewed in our `CalendarPanel` UI. This is done by retrieving the list of calendars stored in our `CalendarPanel`
and then adding the appointment to one or more of these calendars. This command extends `Command` so it *does not support the undo/redo feature*.

To be able to create appointments, add them to calendars and view the calendar with the added appointments, the external CalendarFX package is used. The API for all the CalendarFX classes and methods used can be found http://dlsc.com/wp-content/html/calendarfx/apidocs/index.html[here].

* For the calendar, the `CelebCalendar` class is used, which extends the default `Calendar` class from CalendarFX used to describe a calendar.

* For the appointment, the `Appointment` class is used, which is extended from `Entry`, the default class used to represent an entry in a `Calendar` in CalendarFX.

* All `CelebCalendar` instances reside in an instance of `CalendarSource`, the class used to store a group of calendars in CalendarFX.

* This instance of `CalendarSource` is atttached to our `CalendarView` which is the GUI for our calendar.

[NOTE]
Inheritance from the base classes of the external package is done so that we can add in additional methods as necessary.

Right now, the addAppointment command takes in up to 6 parameters. They are:

* Appointment name [Compulsory field]
* Location
* Start Date
* Start Time
* End Date
* End Time

The `AddAppointmentCommandParser` is able to create sensible appointments even if 1 or more of the non-compulsory fields are not included. The snippet code below shows how the parsing is handled:

[source,java]
----
public AddAppointmentCommand parse(String args) throws ParseException {
    ArgumentMultimap argMultiMap = ArgumentTokenizer.tokenize(args, PREFIX_NAME, PREFIX_START_TIME,
            PREFIX_START_DATE,  PREFIX_LOCATION, PREFIX_END_TIME, PREFIX_END_DATE);

    if (!arePrefixesPresent(argMultiMap, PREFIX_NAME)
            || !argMultiMap.getPreamble().isEmpty()) {
        throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                AddAppointmentCommand.MESSAGE_USAGE));
    }

    try {
        String appointmentName = ParserUtil.parseGeneralName(argMultiMap.getValue(PREFIX_NAME)).get();
        Optional<LocalTime> startTimeInput = ParserUtil.parseTime(argMultiMap.getValue(PREFIX_START_TIME));
        Optional<LocalDate> startDateInput = ParserUtil.parseDate(argMultiMap.getValue(PREFIX_START_DATE));
        Optional<LocalTime> endTimeInput = ParserUtil.parseTime(argMultiMap.getValue(PREFIX_END_TIME));
        Optional<LocalDate> endDateInput = ParserUtil.parseDate(argMultiMap.getValue(PREFIX_END_DATE));
        Optional<String> locationInput = ParserUtil.parseGeneralName(argMultiMap.getValue(PREFIX_LOCATION));

        String location = null;
        LocalTime startTime = LocalTime.now();
        LocalDate startDate = LocalDate.now();
        LocalTime endTime = LocalTime.now();
        LocalDate endDate = LocalDate.now();

        if (startTimeInput.isPresent()) {
            startTime = startTimeInput.get();
            endTime = startTimeInput.get();
        }
        if (endTimeInput.isPresent()) {
            endTime = endTimeInput.get();
        }
        if (startDateInput.isPresent()) {
            startDate = startDateInput.get();
            endDate = startDateInput.get();
        }
        if (endDateInput.isPresent()) {
            endDate = endDateInput.get();
        }
        if (locationInput.isPresent()) {
            location = locationInput.get();
        }
        ...
    }
    ...
}
----

The format for all the fields are located inside of `Appointment` and are as follows:

[source,java]
----
public class Appointment extends Entry {

    public static final String MESSAGE_NAME_CONSTRAINTS =
            "Appointment names should only contain alphanumeric characters and spaces, and it should not be blank"; // used for name and location

    public static final String MESSAGE_TIME_CONSTRAINTS =
            "Time should be a 2 digit number between 00 to 23 followed by a :"
            + " followed by a 2 digit number beetween 00 to 59. Some examples include "
            + "08:45, 13:45, 00:30";
    public static final String MESSAGE_DATE_CONSTRAINTS =
            "Date should be a 2 digit number between 01 to 31 followed by a -"
            + " followed by a 2 digit number between 01 to 12 followed by a -"
            + " followed by a 4 digit number describing a year. Some months might have less than 31 days."
            + " Some examples include: 13-12-2018, 02-05-2019, 28-02-2018";

    public static final DateTimeFormatter TIME_FORMAT = DateTimeFormatter.ofPattern("HH:mm");

    public static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("dd-MM-uuuu")
            .withResolverStyle(ResolverStyle.STRICT); // prevent incorrect dates
    ...
}
----

The snippet below shows the state of the Celeb Scheduler app before input of the `AddAppointmentCommand`:

.Image of Celeb Scheduler without any appointments
image::BeforeAddAppointment.png[width="800"]

After input of the command we will have:

.Image of Celeb Scheduler with newly added appointment
image::AfterAddAppointment.png[width="800"]

=== Appointment Storage Feature
==== Current Implementation
The storing of appointment is facilitated by the `XmlAppointmentListStorage` class, which resides in the `Storage` component.
It supports the retrieval and storage for appointments made by the user.

During start-up of application, the storage component will be initialized by the `MainApp`, which retrieves information from the specified file path in `UserPrefs`.

The following code snippet shows how the storage component will be initialized by the `MainApp`.
[source,java]
----
public void init() throws Exception {
        // initializes application.

        UserPrefsStorage userPrefsStorage = new JsonUserPrefsStorage(config.getUserPrefsFilePath());
        userPrefs = initPrefs(userPrefsStorage);
        AddressBookStorage addressBookStorage = new XmlAddressBookStorage(userPrefs.getAddressBookFilePath());
        AppointmentListStorage appointmentListStorage =
                new XmlAppointmentListStorage(userPrefs.getAppointmentListFilePath());
        storage = new StorageManager(addressBookStorage, userPrefsStorage, appointmentListStorage);

        // initializes other component in the application.
    }
----

In the `XmlAppointmentListStorage` class, it allows developers to use methods:

* `readAppointmentList`, to retrieve a `ReadOnlyAppointmentList`
** This is done by checking if the file exist, and load the list from `XmlSerializableAppointmentList`.
* `saveAppointmentList`, to write information into `filePath` specified in `userPrefs`
** This is done by creating a new file and rewriting to the list in `XmlSerializableAppointmentList`.

While the `XmlAppointmentListStorage` class allows access to data stored on the hard disk, the `XmlSerializableAppointmentList` class represents the data of the appointment list for the calendar.
In `XmlSerializableAppointmentList`, it contains a `List` of XML formats of appointments `XmlAdaptedAppointment`.
`XmlAdaptedAppointment` will then contain essential information of different `Appointment` in `AppointmentList` in the `Model` component, which includes:

* `title` of appointment
* `interval` of appointment indicating its starting and ending time
* `fullDay` tag of appointment indicating whether if appointment is a full-day event
* `calendarName` of which the appointment is allocated to
* `location` of appointment that is going to happen

==== Design Considerations
===== Aspect: Implementing of `AppointmentListStorage`
* **Alternative 1 (current choice):** Adapting existing `AddressBookStorage`
** Pros: Allows similar structure that can be maintained easily in `Storage` component
** Cons: Prevents major overhaul in future if necessary
* **Alternative 2:** Redefining `AppointmentListStorage`
** Pros: Allows flexibility in implementation
** Cons: Confuses developer with different requirements for a single component

===== Aspect: Usage of data structures for `Appointment`
* **Alternative 1 (current choice):** Using a single `List`
** Pros: Allows simplicity
** Cons: Slows the application if there are too many appointments
* **Alternative 2:** Using a single `Set` such as `TreeSet`
** Pros: Lowers impact in speed when there are many appointments
** Cons: Complicates implementation when speed is not an issue

== Documentation
This section shows you how to document your project effectively.

Use AsciiDoc a lightweight markup language for writing documentation.

[NOTE]
Chose AsciiDoc(markup language) over markdown language format because it provides more flexibility with regards to formatting.


=== Editing Documentation

Refer to <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> for instructions on how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

Refer to <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> for instructions on how to deploy GitHub pages using Travis.

=== Converting Documentation to PDF format

Use https://www.google.com/chrome/browser/desktop/[Google Chrome] to convert documents to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format:

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, proceed to click `Save` to save a copy of the file in PDF format. For the best result, use the settings indicated in the screenshot below.

*Menu below will appear after step 3*

.Saving documentation as PDF files in Chrome
image::chrome_save_as_pdf.png[width="300"]

[[Testing]]
== Testing

Testing is very important as it allows us to find application defects that were made during development, and it should be done constantly. It can be expensive if software testing is done only in the later stages of development, as a bug may affect different components of the project.

=== Types of tests

There are two types of tests that we can run during the development of the project:

.  *GUI Tests* - These are tests involving the GUI. They include:
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components of the software. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include:
..  _Unit tests_ that target the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that check the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  _Hybrids of unit and integration tests_ that check multiple code units as well as how they are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Running Tests

There are three ways to run tests.

*Method 1: Using Gradle (headless)*

* Open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`).

[NOTE]
GUI tests can be run in _headless_ mode due to the https://github.com/TestFX/TestFX[TestFX] library. GUI tests do not show up on the screen in headless mode, which allows you to work on other matters while tests are running.

[TIP]
Using Gradle (headless) is the most reliable way to run tests. Other testing methods may fail some GUI tests due to platform/resolution-specific idiosyncrasies.

[TIP]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`).

*Method 3: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`.
* To run a subset of tests, right-click on a test package or a test class, and choose `Run 'Tests in '<test package or test class>''`.


=== Troubleshooting Testing
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

== Dev Ops

Dev Ops is a software engineering culture and practice that aims at unifying software development (Dev) and software operations (Ops).
Dev Ops advocates automation and monitoring at all steps of software construction. This section illustrates how we adopt this practice in developing CelebManager.

=== Build Automation

We use Gradle for build automation. +
Refer to <<UsingGradle#, UsingGradle.adoc>> for more details.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. +
Refer to <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Coverage Reporting

We use https://coveralls.io/[Coveralls] to track the code coverage of our projects. +
Refer to <<UsingCoveralls#, UsingCoveralls.adoc>> for more details.

=== Documentation Previews

We use https://www.netlify.com/[Netlify] to see a preview of how the HTML version of changed asciidoc files will look
like when a pull request is merged. +
Refer to <<UsingNetlify#, UsingNetlify.adoc>> for more details.

=== Making a Release

We do the following steps to create a new release:

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number, e.g. `v0.1`.
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

We automate _dependencies_ on third-party libraries using Gradle.
There is no need to include those libraries in the repo or download them manually.

[[GetStartedProgramming]]
[appendix]
== Product Scope

*Target user profile*:

* has a need to manage a significant number of contacts
* prefers desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI Apps
* needs to manage several people's (celebrities') schedule
* has a need to link contacts to appointments

*Value proposition*: manage contacts faster than a typical mouse/GUI driven app

=== Feature Contribution

**MAJOR**

*Adding, deleting, editing appointments*: Able to create, delete and edit appointments within the application. (By Muruges)

*Listing appointments* : Able to list appointments within a date range. (By Muruges)

*Showing location on map*: Able to show the location of an appointment using address in maps. (By Damien)

*Showing route on map*: Able to show the rough route used to calculate the distance and time of travel. (By Damien)

*Storing appointments*: Able to parse appointments information from storage, and save new and edited appointment
information into storage. (By Tzer Bin)

*Reminding of appointments*: Able to draft an email template to remind persons associated with the appointment and fill in the addressees' emails automatically. (By Jinyi)


**MINOR**

*Adding attendees and POCs*: Able to add a list of celebrities and a list of Points of Contact to each appointment. (By Muruges)

*Switching between different calendar views*: Able to switch to view appointments on the calendar by day, week, month and year with CLI. (Jinyi)

*Customizing visual themes*: Able to customize visual themes of the application. (By Tzer Bin)

*Removing a tag*: Able to remove a tag from each person with it in the application. (By Jinyi)

*Calculating distance and time of travel between 2 location*: Able to calculate the distance and time required to travel between
two locations. (By Damien)

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="90%",cols="15%,<20%,<30%,<40%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |user |add a new person |access contacting information of the person from the App

|`* * *` |user |delete a person |remove contacts that I no longer need

|`* * *` |user |find a person by name |locate details of persons without having to go through the entire list

|`* * *` |user |undo a previous command |remove the change made by mistake

|`* * *` |user |redo a previous command |restore the change removed by mistake

|`* * *` |user |have a calendar inside the address book |know the date and day

|`* * *` |user |display appointments on calendar by day, week, and month |check appointments in different time frames

|`* * *` |user |add an appointment to a calendar |schedule different appointments without time clashes

|`* * *` |user |delete an appointment from a calendar |remove appointments that are cancelled

|`* * *` |user |edit an appointment in a calendar |change the information about the appointment when there is a change in plan or arrangement

|`* * *` |user |save appointments |get appointments loaded in the calendar automatically when I re-launch the App

|`* * *` |user |get alerted for upcoming appointments |set my priorities straight

|`* * *` |user |see the location of an appointment in a map |plan for travel

|`* * *` |user |see various landmarks around a specific location in a road map |understand better the roads around the location

|`* * *` |user |see various landmarks around a specific location in a satellite map |see in real time the actual layout of the surrounding

|`* * *` |user |zoom in and out of the map of a location in a map |view the location in different levels of details

|`* * *` |user |see the best route of travel by driving between two locations in a map |plan for the fastest travel

|`* * *` |celebrity manager who chauffeurs celebrities |see the best route of travel by driving between two locations in a map |plan for the shortest travel

|`* * *` |celebrity manager who chauffeurs celebrities |know if two locations can be reached by driving |foresee any problems and plan ahead

|`* * *` |celebrity manager who chauffeurs celebrities |know the estimated distance between two locations by driving |cater enough time for travelling to avoid being late

|`* * *` |celebrity manager who chauffeurs celebrities |know the estimated time of travel between two locations by driving |reduce the time of travel to reach an appointment location

|`* * *` |celebrity manager |have multiple calendars to display appointments for different celebrities |manage multiple celebrities' appointments

|`* *` |user |hide <<private-contact-detail,private contact details>> by default |minimize chance of someone else seeing them by accident

|`* *` |user |change the size of different windows of the App |customise the window sizes

|`* *` |user who contacts different parties involved in an appointment |draft the message about appointment details automatically |save time to draft the email

|`* *` |user who frequently contacts certain people |sort the contacts by contacting frequency |find those people I frequently contact easily

|`* *` |user |change the colour scheme of the App |choose my preferred colour scheme

|`* *` |celebrity manager |group celebrities by different talents |find celebrities by talent easily

|`* *` |celebrity manager managing celebrities of the same group|add an appointment to the calendars of these celebrities at the same time |save time

|`*` |user with many international contacts |group contacts by country code |see my contacts from different countries

|`*` |user of previous versions of the App |transfer my contacts to the new version |save the trouble of adding the contacts again

|`*` |user with poor eyesight |the address book to read out the contacts to me |use it more efficiently

|`*` |user |output the contacts to a separate list |have a backup copy of the contacts

|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `CelebManager` and the *Actor* is the `user`, unless specified otherwise)

=== Use case: Delete person

*MSS*

1.  User requests to list persons.
2.  Celeb Scheduler shows a list of persons.
3.  User requests to delete a specific person in the list.
4.  Celeb Scheduler deletes the person.

+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. CelebManager shows an error message.
+
Use case resumes at step 2.

=== Use case: Undo

*MSS*

1.  User requests to undo.
2.  Celeb Scheduler undoes the latest executed command that mutates the data.

+
Use case ends.

*Extensions*

[none]
* 2a. There is no executed command that mutates the data.
+
[none]
** 2a1. CelebManager shows an error message.
+
Use case ends.

=== Use case: Redo

*MSS*

1.  User requests to redo.
2.  Celeb Scheduler redoes the latest executed undo command.

+
Use case ends.

*Extensions*

[none]
* 2a. There is no executed undo command.
+
[none]
** 2a1. CelebManager shows an error message.
+
Use case ends.

=== Use case: Remove tag

*MSS*

1. User requests to remove a tag.
2. Celeb Scheduler removes the tag from any person having it.

+
Use case ends.

*Extensions*

[none]
* 1a. The tag does not exist.
+
[none]
** 1a1. Celeb Scheduler shows an error message.
+
Use case ends.

=== Use case: Add appointment

*MSS*

1.  User requests to add an appointment.
2.  Celeb Scheduler adds the appointment to the currently displayed calendar.

+
Use case ends.

*Extensions*

[none]
* 1a. Appointment to add has incorrect details or format.
+
[none]
** 1a1. Celeb Scheduler shows an error message.
+
Use case ends.

* 2a. Appointment to add clashes with existing appointment.
+
[none]
** 2a1. Celeb Scheduler shows an error message.
+
Use case ends.

=== Use case: View appointment

*MSS*

1.  User requests to view appointment.
2.  Celeb Scheduler shows the appointment's details.

+
Use case ends.

*Extensions*

[none]
* 1a. Appointment to view does not exist.
+
[none]
** 1a1. Celeb Scheduler shows an error message.
+
Use case ends.

=== Use case: List appointments

*MSS*

1.  User requests to list appointments from a start date to an end date.
2.  Celeb Scheduler shows a list of appointments within the date range (inclusive).

+
Use case ends.

*Extensions*

[none]
* 1a. The dates are invalid or in wrong format.
+
[none]
** 1a1. Celeb Scheduler outputs an error message.
+
Use case ends.

[none]
* 2a. There is no appointment to show in the date range.
+
[none]
** 2a1. Celeb Scheduler outputs a message that says no appointment in the specified date range.
+
Use case ends.

=== Use case: Delete appointment

*MSS*

1.  User requests to list appointments from a start date to an end date.
2.  Celeb Scheduler shows a list of appointments within the date range (inclusive).
3.  User requests to delete a specific appointment in the list.
4.  Celeb Scheduler deletes the appointment.
+
Use case ends.

*Extensions*

[none]
* 1a. The dates are invalid or in wrong format.
+
[none]
** 1a1. Celeb Scheduler outputs an error message.
+
Use case ends.

[none]
* 2a. There is no appointment to show in the date range.
+
[none]
** 2a1. Celeb Scheduler outputs a message that says no appointment in the specified date range.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. Celeb Scheduler shows an error message.
+
Use case resumes at step 2.

=== Use case: Edit appointment

*MSS*

1.  User requests to list appointments from a start date to an end date.
2.  Celeb Scheduler shows a list of appointments within the date range (inclusive).
3.  User requests to edit a specified appointment.
4.  Celeb Scheduler changes appointment details and displays new appointment details to user.
+
Use case ends.

*Extensions*

[none]
* 1a. The dates are invalid or in wrong format.
+
[none]
** 1a1. Celeb Scheduler outputs an error message.
+
Use case ends.

[none]
* 2a. There is no appointment to show in the date range.
+
[none]
** 2a1. Celeb Scheduler outputs a message that says no appointment in the specified date range.
+
Use case ends.

[none]
* 3a.  The given index is invalid.
+
[none]
** 3a1. Celeb Scheduler shows an error message.
+
Use case resumes at step 2.

[none]
* 3b.  Information entered for edit is invalid.
+
[none]
** 3b1. Celeb Scheduler shows an error message.
+
Use case resumes at step 2.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 1000 persons without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Should be usable by people with no knowledge about command line input.
.  Should respond to any user command within 10 seconds.
.  Should be backward compatible with data produced by earlier versions of the Celeb Scheduler.
.  Should come with automated unit tests and open source code.
.  Should favor DOS style commands over Unix-style commands.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[private-contact-detail]] Private contact detail::
A contact detail that is not meant to be shared with others

[[celebcalendar]] Celeb calendar::
A calendar that contains all appointments a celebrity managed by the user has

[[calendar-view]] Calendar view::
The way in which appointments are displayed in calendar +
[TIP]
Celeb Scheduler currently supports displaying by day, week, month and year.

[[appointment]] Appointment::
A meeting between contacts at a specific time, date and location +
An appointment has a specific name

[[attendees]] Attendees::
A list of contacts who are attending an appointment

[[points-of-contacts]] Points of Contacts::
A list of contacts involved in an appointment but not attending it

[[blacklist]] Blacklist::
A list of contacts which should be marked for being untrustworthy or unacceptable

[[UI]] User Interface::
The Design and looks of the software

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the App manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch
This section includes instructions to test the launch and re-launch of the App. +
For each subsequent launch, window size and location should be the same as the settings before closing the App for previous launch.

. Initial launch

.. Download the jar file
.. Copy into an empty folder
.. Double-click the jar file +
   _Expected: Celeb Scheduler shows the GUI with a set of sample contacts._
[NOTE]
    The window size may not be optimum.
.. Resize the window to an optimum size
.. Move the window to a different location
.. Close the window

. Subsequent launch
.. Re-launch the App by double-clicking the jar file +
   _Expected: The most recent window size and location are retained._

=== Deleting a person
This section includes instructions to test the delete command of the App.
[NOTE]
Prerequisites: List all persons using the `list` command. Multiple persons in the list.

.. Type `delete 1` in command box and press enter +
   _Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated._
.. Type `delete 0` in command box and press enter +
   _Expected: No person is deleted. Error details shown in the status message. Status bar remains the same._
.. Type other incorrect delete command such as `delete`, `delete x` (where x is larger than the list size) in command box and press enter +
   _Expected: Similar to previous._

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_
