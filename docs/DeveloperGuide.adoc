= CelebManager - Developer Guide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/CS2103JAN2018-W14-B4/main/

By: `CS2103JAN2018-W14-B4`      Since: `Jun 2016`      Licence: `MIT`

== Overview

Whether you are a new developer or a long time contributor to the CelebManager Project,
this developer guide will serve as a helpful reference and source of "how-to" information
when contributing to this project. Included are guides on how to set-up the project locally,
an overview of the architecture and the different features present and how they are implemented.

== Setting Up

This section will discuss the setting up of project for development.

=== Prerequisites

To get started, there are a few prerequisites to have a successful setup. They are:

. *JDK* (Java Development Kit) +
Our programming language of choice is Java in this project.
To be able to work with java, you will need to have JDK installed. You must install version `1.8.0_60` or later. +
You can get the JDK from: +
http://www.oracle.com/technetwork/java/javase/downloads/index.html
+
[NOTE]
Some components of this app will not work with earlier versions of Java 8.
+

. *IntelliJ Integrated Development Environment* (IDE) +
It is possible to setup with other IDEs, but it is much simpler to carry it out in IntelliJ.
All the steps for setup in this document will be specific to IntelliJ.
We highly recommend that you too use IntelliJ unless you have prior experience in working with gradle projects.
You can get IntelliJ from: +
https://www.jetbrains.com/idea/
+
[NOTE]
IntelliJ has Gradle and JavaFx plugins installed by default. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Local Project Setup

To contribute to this project, you will need to work with a local copy of this project. To do so:

. Fork this repo, and clone the fork to your computer.
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first).
. Set up the correct JDK version for Gradle:
.. Click `Configure` > `Project Defaults` > `Project Structure`.
.. Click `New...` and find the directory of the JDK.
. Click `Import Project`.
. Locate the `build.gradle` file, select it and click `OK`.
. Click `Open as Project`.
. Click `OK` to accept the default settings.
. Open a console and run the command `gradlew processResources`. (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Setup Verification

To ensure that you have setup the project correctly: +

. Run the `seedu.address.MainApp` and try a few commands.
. <<Testing,Run the tests>> to ensure they all pass.

=== Setup Configurations

==== Coding Style Configurations

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.adoc[oss-generic coding standards].
IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours.
To rectify:

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS).
. Select `Editor` > `Code Style` > `Java`.
. Click on the `Imports` tab to set the order. Take note of the following:

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements.
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`.

Alternatively, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Documentation Configurations

After forking the repo, links in the documentation will still point to the `CS2103JAN2018-W14-B4/main` repository.
If you plan to develop this as a separate product (i.e. instead of contributing to the `CS2103JAN2018-W14-B4/main` repository), you should replace the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Continuous Integration (CI) Configurations

There are two CI configurations that you can set up.

To set up Travis for performing CI for your fork, please refer to <<UsingTravis#, UsingTravis.adoc>>.
Optionally, to set up AppVeyor for performing CI, please refer to <<UsingAppVeyor#, UsingAppVeyor.adoc>>.

[NOTE]
Travis is an Unix-based software, while AppVeyor is a Windows-based software.
Having both Travis CI and AppVeyor CI ensures your App works on both Unix-based platforms and Windows-based platforms.

You should also set up coverage reporting for your team fork. Please refer to <<UsingCoveralls#, UsingCoveralls.adoc>>.

[NOTE]
Coverage reporting could be useful for a team repository that hosts the final version but it is not that useful for your personal fork.


== Design

Before starting to work on the project after successful configurations, you are encouraged to:

1. Understand the overall design (<<Design-Architecture>>).
2. Understand the product scope (<<GetStartedProgramming>>).

[[Design-Architecture]]
=== Software Architecture

The *_Architecture Diagram_* given below explains the high-level design of the project.

.Architecture diagram
image::Architecture.png[width="600"]

////
[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.
////

`Main` has only one class called link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for:

* Initializing the components in the correct sequence and connects them up with each other at application launch.
* Shutting down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple components.
Two of these classes are vital at the architecture level. These are:

* `EventsCenter` is used by components to communicate with other components using events.
* `LogsCenter` is used by many classes to write log messages to the application's log file.

[NOTE]
`EventsCenter` is written using the https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library].
It is a form of event-driven design.

The rest of the App consists of four components, each defining its _API_ in an interface, and exposing its functionality using a `{Component Name}Manager` class.
The components are:

* <<Design-Ui,*`UI`*>>: The user interface of the application.
* <<Design-Logic,*`Logic`*>>: The command executor of the application.
* <<Design-Model,*`Model`*>>: The container for in-memory data of the application.
* <<Design-Storage,*`Storage`*>>: The driver for reading and writing data of the application.

////
For example, the `Logic` component (see Figure 2) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class diagram of the Logic Component
image::LogicClassDiagram.png[width="800"]

[discrete]
==== Event-driven Design
////

[[Design-Commons]]
=== Common Classes
Common class files, such as `EventsCenter`, are used by multiple components are in the `seedu.addressbook.commons` package.

The _sequence diagram_ below shows how the components interact for the scenario where the user issues the command `delete 1`.
Note that the `Model` simply raises a `AddressBookChangedEvent` when the CelebManager data is changed, instead of asking the `Storage` to save the updates to the hard disk.

.Sequence diagram for `delete 1` command (1)
image::SDforDeletePerson.png[width="800"]


The diagram below shows how the `EventsCenter` reacts to that event, which results in the updates being saved to the hard disk.
The status bar of the UI is also updated to reflect the 'Last Updated' time.
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be coupled to either of them.

.Sequence diagram for `delete 1` command (2)
image::SDforDeletePersonEventHandling.png[width="800"]

=== Architecture Components

[[Design-Ui]]
==== UI Component

The following diagram shows the class diagram of the `UI` component.

.Class diagram of the `UI` component
image::UiClassDiagram.png[width="800"]

*API*: link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter`, `BrowserPanel` etc.
All these classes inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework.
The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder.
For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`].

The `UI` component,

* executes user commands using the `Logic` component.
* binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* responds to events raised from various parts of the App and updates the UI accordingly.

[[Design-Logic]]
==== Logic Component

The following diagrams shows the structure of the `Logic` component, and details on `XYZCommand` and `Command` in <<fig-LogicClassDiagram>>.
It describe the overall structure of the `Logic` component and how a single command such as `XYZCommand` and other commands are structured respectively.

[[fig-LogicClassDiagram]]
.Class diagram of the `Logic` component
image::LogicClassDiagram.png[width="800"]

.Structure of commands in the `Logic` component
image::LogicCommandClassDiagram.png[width="800"]

*API*: link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

When the user types in a new command to be parsed:

.  The `Logic` uses the `AddressBookParser` class to parse the user command.
.  A `Command` object is then executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person) and/or raise events.
.  The result of the command execution is then encapsulated as a `CommandResult` object which is passed back to the `Ui`.

The following diagram shows the sequence diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Sequence diagram for the `delete 1` command
image::DeletePersonSdForLogic.png[width="800"]

[[Design-Model]]
==== Model Component

The following diagram shows the class diagram of the `Model` component.
It describes the overall structure of the `Model` component, along with all its sub-components.

.Class diagram of the `Model` component
image::ModelClassDiagram.png[width="800"]

*API*: link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model` component:

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* exposes an unmodifiable `ObservableList<Person>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[[Design-Storage]]
==== Storage Component

The following diagram shows the class diagram of the `Storage` component.
It describes how the overall structure of the `Storage` component and its different sub-components.

.Class diagram of the `Storage` component
image::StorageClassDiagram.png[width="800"]

*API*: link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component:

* saves `UserPref` objects in json format and read it back.
* saves contacts data in xml format and read it back.
* saves appointments data in xml format and read it back.


== Implementation

This section describes some noteworthy features that are implemented in CelebManager.

// tag::removeTag[]
=== RemoveTag Feature
==== Current Implementation

The tag removal mechanism is facilitated by both `RemoveTagCommand`, which resides inside `Logic`, and `removeTag`, which resides in `AddressBook`.
`RemoveTagCommand` removes a specified tag from each person in the address book, and prints out how many persons are affected by this removal.
The following figure shows the inheritance diagram for `RemoveTagCommand`:

.Inheritance diagram for `Command`
image::RemoveTagCommandClassDiagram.png[width=""]

The `RemoveTagCommand` class inherits from the `UndoableCommand` class.
Similar to the other undoable commands like `DeleteCommand`, it supports the undo/redo feature.

Unlike `DeleteCommand` that can raise `PersonNotFoundException` when the `index` of the `person` to be deleted does not exist,
`RemoveTagCommand` can remove a non-existing tag from the address book, but implicitly tell the user that the tag does not exist
by showing that, the number of persons affected by the removal is 0.

The snippet code below shows the implementation of `executeUndoableCommand` in `RemoveTagCommand`:

[source,java]
----
public class RemoveTagCommand extends UndoableCommand {
    ...
    public static final String MESSAGE_DELETE_TAG_SUCCESS = "Removed Tag %1$s and %2$s person(s) affected.";
    ...

    @Override
    public CommandResult executeUndoableCommand() {
        requireNonNull(tagToRemove);
        int numberOfAffectedPersons = model.removeTag(tagToRemove);
        return new CommandResult(String.format(MESSAGE_DELETE_TAG_SUCCESS, tagToRemove, numberOfAffectedPersons));
    }

    ...
}
----

The snippet code below shows the implementation of `removeTag` in `AddressBook`:

[source,java]
----
public class AddressBook {
    /**
     * Removes {@code tag} from all persons in this {@code AddressBook}.
     * @returns the number of {@code person}s with this {@code tag} removed.
     */
    public int removeTag(Tag tag) {
        int count = 0;
        for (Person person: persons) {
            if (person.removeTag(tag)) {
                count++;
            }
        }
        if (count > 0) {
            removeUnusedTags();
        }
        return count;
    }
    ...
}
----

Note that `removeUnusedTags` is called inside `removeTag` when there is at least one person affected by the removal.
This is because this operation removes the tag from each person with it, and thus after the operation, no person in the
address book should have the tag, and hence the unused tag should be removed from `tags` inside the address book.

Suppose the current address book has two types of tags, `friends` and `husband`.
The figure below shows the state of `PersonListPanel`:

.State of `PersonListPanel` before executing `removeTag friends`
image::BeforeRemoveTag.png[width=""]

After the successful execution of `removeTag friends`, `PersonListPanel` will be updated to the diagram below:

.State of `PersonListPanel` after executing `removeTag friends`
image::AfterRemoveTag.png[width=""]

The following sequence diagram shows how the command works:

.Sequence diagram of removeTag command
image::RemoveTagSequenceDiagram.png[width=""]

==== Design Considerations

===== Aspect: Command result for removal of non-existing `tag`
* **Alternative 1 (current choice):** Output `tag` is removed and 0 person affected
** Pros: Easy to implement.
** Cons: Does not make it explicit to users that the `tag` being removed does not exist in the address book.
* **Alternative 2:** Output the `tag` cannot be removed
** Pros: Makes it clear to users that the `tag` does not exist and thus cannot be removed.
** Cons: Does not invalidate the removal and can thus be confusing to users whether this removal is legal.
* **Alternative 3:** Output error and invalid command format
** Pros: Follows the common logical convention and makes it clear to users that the removal is not legal.
** Cons: Requires the creation of additional exception class and exception handling methods.


// tag::undoredo[]
=== Undo/Redo Command Feature
==== Current Implementation

The undo command allows users to reverse the effect of the previous command, and the redo command allows the users to reverse the effects of undoing commands.

The undo/redo mechanism is facilitated by an `UndoRedoStack` in `LogicManager` class. It supports undoing and redoing of commands that modifies the state of the address book, such as `add` and `edit`.

In the implementation, these commands will inherit from `UndoableCommand` class, while the commands that cannot be undone will inherit from the `Command` class instead.


The following figure shows the inheritance diagram with regards to the feature:

.Inheritance diagram for undoable commands
image::LogicCommandClassDiagram.png[width="800"]

From the figure, the `UndoableCommand` class provides an interface between the abstract `Command` class and concrete commands that can be undone, such as the `DeleteCommand`.

`UndoableCommand` contains high-level algorithms for additional tasks, such as saving the application state before command execution.
Its child classes implements the details of how to execute the specific command.

[NOTE]
Undoable commands require additional tasks to be completed, such as saving the application state, before command execution.

[NOTE]
The technique of containing the high-level algorithms in the parent class, while implementing lower-level algorithms in child classes is also known as the https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern].

With the additional interface, the commands that are undoable are implemented in this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

Commands that are not undoable are implemented this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

The `UndoRedoStack` will be empty at the beginning when the user first launches the application.


For example, when the user executes a `delete 5` command, an `UndoableCommand`, to delete the 5th person in the address book, the current state of the address book is saved.
The `delete 5` command will then be pushed onto the `undoStack`.
The current state of the application is then saved together with the command.
The following figure shows the illustration after executing the command.

.Execution of `delete 5` command
image::UndoRedoStartingStackDiagram.png[width="800"]

As the user continues to execute commands that are undoable in the application, more commands are added into the `undoStack`.
For example, the user may execute an `add n/David ...` command to add a new person.
The following figure shows the illustration after executing the second command.

.Execution of `add n/David ...` command
image::UndoRedoNewCommand1StackDiagram.png[width="800"]

[NOTE]
If a command fails its execution, it will not be pushed to the `undoStack` at all.

If the user decides to undo that action using `undo` command, the `undoStack` will pop the most recent command, and push the command into the `redoStack`.
The application will restore to the state before the `add n/David ...` command executed.
The following figure shows the illustration after executing the `undo` command.

.Execution of `undo` command
image::UndoRedoExecuteUndoStackDiagram.png[width="800"]

[NOTE]
If the `undoStack` is empty, then there are no other commands left to be undone.
An `Exception` will be thrown when popping the `undoStack`.

The following figure shows the sequence diagram on how the `undo` command works.

.Sequence diagram of `undo` command
image::UndoRedoSequenceDiagram.png[width="800"]

The `redo` command pops the most recent undone command from `redoStack`, and push the command to the `undoStack`.
This will also restore the address book to the state after the command is executed.

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone.
An `Exception` will be thrown when popping the `redoStack`.

////
The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`. This time the `redoStack` is no longer empty. It will be purged as it no longer make sense to redo the `add n/David` command (this is the behavior that most modern desktop applications follow).

image::UndoRedoNewCommand2StackDiagram.png[width="800"]

Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution:

image::UndoRedoNewCommand3StackDiagram.png[width="800"]

The following activity diagram summarize what happens inside the `UndoRedoStack` when a user executes a new command:

image::UndoRedoActivityDiagram.png[width="650"]
////

==== Design Considerations


===== Aspect: Implementation of `UndoableCommand`

* **Alternative 1 (current choice):** Add a new abstract method `executeUndoableCommand()`
** Pros: We will not lose any undone/redone functionality as it is now part of the default behaviour. Classes that deal with `Command` do not have to know that `executeUndoableCommand()` exist.
** Cons: Hard for new developers to understand the template pattern.
* **Alternative 2:** Just override `execute()`
** Pros: Does not involve the template pattern, easier for new developers to understand.
** Cons: Classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to undo/redo.

===== Aspect: Execution of `undo` and `redo` commands

* **Alternative 1 (current choice):** Saves the entire address book.
** Pros: Easy to implement.
** Cons: May have performance issues in terms of memory usage.
* **Alternative 2:** Individual command knows how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete`, just save the person being deleted).
** Cons: We must ensure that the implementation of each individual command are correct.


===== Aspect: Type of commands that can be undone/redone

* **Alternative 1 (current choice):** Only include commands that modifies the address book (`add`, `clear`, `edit`).
** Pros: We only revert changes that are hard to change back (the view can easily be re-modified as no data are * lost).
** Cons: User might think that undo also applies when the list is modified (undoing filtering for example), * only to realize that it does not do that, after executing `undo`.
* **Alternative 2:** Include all commands.
** Pros: Might be more intuitive for the user.
** Cons: User have no way of skipping such commands if he or she just want to reset the state of the address * book and not the view.
**Additional Info:** See our discussion  https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here].


===== Aspect: Type of data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use separate stack for undo and redo
** Pros: Easy to understand for new Computer Science student undergraduates to understand, who are likely to be * the new incoming developers of our project.
** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update * both `HistoryManager` and `UndoRedoStack`.
* **Alternative 2:** Use `HistoryManager` for undo/redo
** Pros: We do not need to maintain a separate stack, and just reuse what is already in the codebase.
** Cons: Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two * different things.
// end::undoredo[]

=== AddAppointment Feature
==== Current Implementation

The AddAppointment mechanism is facilitated by the `AddAppointmentCommand`, which resides inside `Logic`. It supports the adding of an appointment to an existing calendar.
The appointment, if added successfully, can be viewed in our `CalendarPanel` UI. This is done by retrieving the list of calendars stored in our `CalendarPanel`
and then adding the appointment to one or more of these calendars. This command extends `Command` so it *does not support the undo/redo feature*.

To be able to create appointments, add them to calendars and view the calendar with the added appointments, the external CalendarFX package is used. The API for all the CalendarFX classes and methods used can be found http://dlsc.com/wp-content/html/calendarfx/apidocs/index.html[here].

* For the calendar, the `CelebCalendar` class is used, which extends the default `Calendar` class from CalendarFX used to describe a calendar.

* For the appointment, the `Appointment` class is used, which is extended from `Entry`, the default class used to represent an entry in a `Calendar` in CalendarFX.

* All `CelebCalendar` instances reside in an instance of `CalendarSource`, the class used to store a group of calendars in CalendarFX.

* This instance of `CalendarSource` is atttached to our `CalendarView` which is the GUI for our calendar.

[NOTE]
Inheritance from the base classes of the external package is done so that we can add in additional methods as necessary.

Right now, the addAppointment command takes in up to 6 parameters. They are:

* Appointment name [Compulsory field]
* Location
* Start Date
* Start Time
* End Date
* End Time

The `AddAppointmentCommandParser` is able to create sensible appointments even if 1 or more of the non-compulsory fields are not included. The snippet code below shows how the parsing is handled:

[source,java]
----
public AddAppointmentCommand parse(String args) throws ParseException {
    ArgumentMultimap argMultiMap = ArgumentTokenizer.tokenize(args, PREFIX_NAME, PREFIX_START_TIME,
            PREFIX_START_DATE,  PREFIX_LOCATION, PREFIX_END_TIME, PREFIX_END_DATE);

    if (!arePrefixesPresent(argMultiMap, PREFIX_NAME)
            || !argMultiMap.getPreamble().isEmpty()) {
        throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                AddAppointmentCommand.MESSAGE_USAGE));
    }

    try {
        String appointmentName = ParserUtil.parseGeneralName(argMultiMap.getValue(PREFIX_NAME)).get();
        Optional<LocalTime> startTimeInput = ParserUtil.parseTime(argMultiMap.getValue(PREFIX_START_TIME));
        Optional<LocalDate> startDateInput = ParserUtil.parseDate(argMultiMap.getValue(PREFIX_START_DATE));
        Optional<LocalTime> endTimeInput = ParserUtil.parseTime(argMultiMap.getValue(PREFIX_END_TIME));
        Optional<LocalDate> endDateInput = ParserUtil.parseDate(argMultiMap.getValue(PREFIX_END_DATE));
        Optional<String> locationInput = ParserUtil.parseGeneralName(argMultiMap.getValue(PREFIX_LOCATION));

        String location = null;
        LocalTime startTime = LocalTime.now();
        LocalDate startDate = LocalDate.now();
        LocalTime endTime = LocalTime.now();
        LocalDate endDate = LocalDate.now();

        if (startTimeInput.isPresent()) {
            startTime = startTimeInput.get();
            endTime = startTimeInput.get();
        }
        if (endTimeInput.isPresent()) {
            endTime = endTimeInput.get();
        }
        if (startDateInput.isPresent()) {
            startDate = startDateInput.get();
            endDate = startDateInput.get();
        }
        if (endDateInput.isPresent()) {
            endDate = endDateInput.get();
        }
        if (locationInput.isPresent()) {
            location = locationInput.get();
        }
        ...
    }
    ...
}
----

The format for all the fields are located inside of `Appointment` and are as follows:

[source,java]
----
public class Appointment extends Entry {

    public static final String MESSAGE_NAME_CONSTRAINTS =
            "Appointment names should only contain alphanumeric characters and spaces, and it should not be blank"; // used for name and location

    public static final String MESSAGE_TIME_CONSTRAINTS =
            "Time should be a 2 digit number between 00 to 23 followed by a :"
            + " followed by a 2 digit number beetween 00 to 59. Some examples include "
            + "08:45, 13:45, 00:30";
    public static final String MESSAGE_DATE_CONSTRAINTS =
            "Date should be a 2 digit number between 01 to 31 followed by a -"
            + " followed by a 2 digit number between 01 to 12 followed by a -"
            + " followed by a 4 digit number describing a year. Some months might have less than 31 days."
            + " Some examples include: 13-12-2018, 02-05-2019, 28-02-2018";

    public static final DateTimeFormatter TIME_FORMAT = DateTimeFormatter.ofPattern("HH:mm");

    public static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("dd-MM-uuuu")
            .withResolverStyle(ResolverStyle.STRICT); // prevent incorrect dates
    ...
}
----

The figure below shows the state of the application before input of the `AddAppointmentCommand`:

.State of application without any appointments
image::BeforeAddAppointment.png[width="800"]

After input of the command, we will have:

.State of application with newly added appointment
image::AfterAddAppointment.png[width="800"]


////
=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).
////

=== Appointment Storage Feature
==== Current Implementation
The storing of appointment is facilitated by the `XmlAppointmentListStorage` class, which resides in the `Storage` component.
It supports the retrieval and storage for appointments made by the user.

During start-up of application, the storage component will be initialized by the `MainApp`, which retrieves information from the specified file path in `UserPrefs`.

The following code snippet shows how the storage component will be initialized by the `MainApp`.
[source,java]
----
public void init() throws Exception {
        // initializes application.

        UserPrefsStorage userPrefsStorage = new JsonUserPrefsStorage(config.getUserPrefsFilePath());
        userPrefs = initPrefs(userPrefsStorage);
        AddressBookStorage addressBookStorage = new XmlAddressBookStorage(userPrefs.getAddressBookFilePath());
        AppointmentListStorage appointmentListStorage =
                new XmlAppointmentListStorage(userPrefs.getAppointmentListFilePath());
        storage = new StorageManager(addressBookStorage, userPrefsStorage, appointmentListStorage);

        // initializes other component in the application.
    }
----

In the `XmlAppointmentListStorage` class, it allows developers to use methods:

* `readAppointmentList`, to retrieve a `ReadOnlyAppointmentList`
** This is done by checking if the file exist, and load the list from `XmlSerializableAppointmentList`.
* `saveAppointmentList`, to write information into `filePath` specified in `userPrefs`
** This is done by creating a new file and rewriting to the list in `XmlSerializableAppointmentList`.

While the `XmlAppointmentListStorage` class allows access to data stored on the hard disk, the `XmlSerializableAppointmentList` class represents the data of the appointment list for the calendar.
In `XmlSerializableAppointmentList`, it contains a `List` of XML formats of appointments `XmlAdaptedAppointment`.
`XmlAdaptedAppointment` will then contain essential information of different `Appointment` in `AppointmentList` in the `Model` component, which includes:

* `title` of appointment
* `interval` of appointment indicating its starting and ending time
* `fullDay` tag of appointment indicating whether if appointment is a full-day event
* `calendarName` of which the appointment is allocated to
* `location` of appointment that is going to happen

==== Design Considerations
===== Aspect: Implementing of `AppointmentListStorage`
* **Alternative 1 (current choice):** Adapting existing `AddressBookStorage`
** Pros: Allows similar structure that can be maintained easily in `Storage` component
** Cons: Prevents major overhaul in future if necessary
* **Alternative 2:** Redefining `AppointmentListStorage`
** Pros: Allows flexibility in implementation
** Cons: Confuses developer with different requirements for a single component

===== Aspect: Usage of data structures for `Appointment`
* **Alternative 1 (current choice):** Using a single `List`
** Pros: Allows simplicity
** Cons: Slows the application if there are too many appointments
* **Alternative 2:** Using a single `Set` such as `TreeSet`
** Pros: Lowers impact in speed when there are many appointments
** Cons: Complicates implementation when speed is not an issue

// tag::showlocation[]
=== ShowLocation Feature
==== Current Implementation

The ShowLocation mechanism is facilitated by the `ShowLocationCommand`, which resides inside `Logic`. It supports the viewing of location
in the `MapPanel` UI by updating the state of the `MapPanel`. This is done by re-centering the `MapPanel` to the latitude and longitude of the
location and identifying it with a location marker. This command inherits from `Command` so it *does not support the undo/redo feature*.

The following figure shows the marker that is used to identify the location in the `MapPanel`:

.Location marker
image::LocationMarker.png[width="50"]

The following diagram shows the inheritance diagram for `ShowLocationCommand`:

.Inheritance diagram for `Command`
image::ShowLocationLogicCommandClassDiagram.png[width=""]

As you can see from the diagram, `ShowLocationCommand` inherits from the Command class and is not part of the Undoable Command.
Similar to the other commands like `FindCommand` it will not be identified by the undo/redo feature.

This command does not use the `Person` `Address` model to search for a specific location, it uses the `MapAddress` model. This is due to
the due to the difference in address specification details as the `Address` model is too specific for the command to work.
An example would be the details of unit number (e.g #11-111) which will not be valid for this command.

The main difference between both model is shown below in the two diagrams.

The snippet code below shows the diagram of `Address` model:

[source,java]
----
public class Address {
    public static final String MESSAGE_ADDRESS_CONSTRAINTS =
                "Person addresses can take any values, and it should not be blank";
    /*
     * The first character of the address must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String ADDRESS_VALIDATION_REGEX = "[^\\s].*";
    /**
     * Returns true if a given string is a valid person email.
     */
    public static boolean isValidAddress(String test) {
        return test.matches(ADDRESS_VALIDATION_REGEX);
    }
    ...
}
----

The snippet code below shows the diagram of `MapAddress` model:

[source,java]
----
public class MapAddress {
    public static final String MESSAGE_ADDRESS_MAP_CONSTRAINTS =
            "Address should be in location name, road name, block and road name or postal code format.\n"
                    + "Note:(Person address may not be valid as it consist of too many details like unit number)"
    /*
     * The first character of the address must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String ADDRESS_VALIDATION_REGEX = "[^\\s].*";
    ...
    /**
     * Returns true if a given string is a valid map address.
     */
    public static boolean isValidAddress(String test) {
        boolean isValid;
        Geocoding testAddress = new Geocoding();
        isValid = testAddress.checkIfAddressCanBeFound(test);
        return test.matches(ADDRESS_MAP_VALIDATION_REGEX) && isValid;
    }
    ...
}
----
The difference to note is the `isValidAddress` method, where `Address` only checks for *blank space* whereas `MapAddress`
checks for *blank space and the validity of location in google server*. Thus, making the command more restrictive to location,
 road, block name and postal code. Any details more than that would result in a higher possibility of it being invalid.

This command uses the `GMAPSFX API` and  `Google Maps Web Services API` library. The `Google Maps Web Services API` is used to create the
`Geocoding` function, which is used to convert `MapAddress` into latitude and longitude form (`LatLng`). The `LatLng` form
is then used by the command to find the exact location in the `MapPanel`. The `GMAPSFX API` allows the
command to re-center and mark the new location which is then shown to the user.

Every new input of this command will remove the previous location marker and add the new marker into the map.

The snippet below shows the state of `MapPanel` before input of `ShowLocation` command:

.Default State of `MapPanel`
image::BeforeInputMap.png[width="400"]

After the input of "showLocation ma/Punggol" the `MapPanel` will be updated to the diagram below:

.State of `MapPanel` after `CommandInput`
image::AfterShowLocationInput.png[width="400"]

Any subsequent inputs will remove the previous location marker and update the `MapPanel` with the new marker

The following sequence diagram shows how the command works:

.Sequence Diagram of `showLocation` Command
image::ShowLocationSequenceDiagram.png[width=""]

==== Design Considerations

===== Aspect: Implementation of `showLocationCommand`
* **Alternative 1 (current choice):** Extend `Command`
** Pros: Easy to understand for new developers who will be developing this project as the command is at the same abstraction level as other commands.
** Cons: Does not have the undo/redo feature as it is not part of `UndoableCommand`.
* **Alternative 2:** Extend `UndoableCommand`
** Pros: Allows for command to have the undo/redo function.
** Cons: Requires more work that may not fit in with our timeline

===== Aspect: Use of address model
* **Alternative 1 (current choice):** Use `MapAddress`
** Pros: Allows the clear distinction of requirements between `MapAddress` and `Address` to avoid confusion
** Cons: Both model are very similar
* **Alternative 2:** Use `Address`
** Pros: Reduces the amount of code/class in the project
** Cons: Will be confusing as different requirements for a single model. Lacks proper organisation.

// tag::estimateRoute[]
=== EstimateRoute Feature
==== Current Implementation

The EstimateRoute mechanism is facilitated by the `EstimateRouteCommand`, which resides inside `Logic`. It supports the viewing of estimated route
in the `MapPanel` UI by updating the state of the `MapPanel`. This is done by re-centering the `MapPanel` to the new route. This command inherits from `Command` so it *does not support the undo/redo feature*.



The following figure shows the marker that is used to identify the start and end location in the `MapPanel`:

.Location marker
image::LocationMarker.png[width="50"]

The following diagram shows the inheritance diagram for `EstimateRouteCommand`:

.Inheritance diagram for `Command`
image::ShowLocationLogicCommandClassDiagram.png[width=""]

As you can see from the diagram, `EstimateRouteCommand` inherits from the Command class and is not part of the Undoable Command.
Similar to the other commands like `FindCommand` it will not be identified by the undo/redo feature.

This command is similar to the `ShowLocation` feature which does not use the `Person` `Address` model to search for a specific location, it uses the `MapAddress` model. This is due to the difference in address specification details as the `Address` model is too specific for the command to work.
An example would be the details of unit number (e.g #11-111) which will not be valid for this command.

This command uses the `GMAPSFX API` and  `Google Maps Web Services API` library which can be found http://rterp.github.io/GMapsFX/apidocs/[here] and https://googlemaps.github.io/google-maps-services-java/v0.2.6/javadoc/[here] respectively.

The `GMAPSFX` is used to create the `MapPanel` which allows the
command to re-center the map view, create the route, mark the start and end location which is then shown to the user.

The `Google Maps Web Services API` is used to create the
`Geocoding` class, which is used to convert `MapAddress` into latitude and longitude form (`LatLng`). The `LatLng` form
is then used by the command to find the exact location in the `MapPanel`. `Google Maps Web Services API` is also used to create the `DistanceEstimate` class, which allows
the calculation of estimated time and distance of travel between two location by driving. `DistanceMatrix` is also used to check if two locations
can be reached by driving.

Every new input of this command will remove the previous route and add the new route into the map.

The snippet below shows the state of `MapPanel` before input of `estimateRoute` command:

.Default State of `MapPanel`
image::BeforeInput.png[width="400"]

After the input of "estimateRoute sma/Punggol ema/NUS" the `MapPanel` will be updated to the diagram below:

.State of `MapPanel` after `CommandInput`
image::AfterEstimateRouteInput.png[width="400"]

Any subsequent inputs will remove any existing marker or route and update the `MapPanel` with the new route.

The following sequence diagram shows how the command works:

.Sequence Diagram of `estimateRoute` Command
image::ShowLocationSequenceDiagram.png[width=""]

==== Design Considerations

===== Aspect: Implementation of `estimateCommand`
* **Alternative 1 (current choice):** Extend `Command`
** Pros: Easy to understand for new developers who will be developing this project as the command is at the same abstraction level as other commands.
** Cons: Does not have the undo/redo feature as it is not part of `UndoableCommand`.
* **Alternative 2:** Extend `UndoableCommand`
** Pros: Allows for command to have the undo/redo function.
** Cons: Requires more work that may not fit in with our timeline

===== Aspect: Use of address model
* **Alternative 1 (current choice):** Use `MapAddress`
** Pros: Allows the clear distinction of requirements between `MapAddress` and `Address` to avoid confusion
** Cons: Both model are very similar
* **Alternative 2:** Use `Address`
** Pros: Reduces the amount of code/class in the project
** Cons: Will be confusing as different requirements for a single model. Lacks proper organisation.

== Documentation
This section shows you how to document your project effectively.

You can use AsciiDoc, a lightweight markup language, for writing documentation.

[NOTE]
AsciiDoc(markup language) is chosen over markdown language format because it provides more flexibility with regards to formatting.


=== Editing of Documentation

Please refer to <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> for instructions on how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing of Documentation

Please refer to <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> for instructions on how to deploy GitHub pages using Travis.

=== Converting of Documentation to PDF format

You can use https://www.google.com/chrome/browser/desktop/[Google Chrome] to convert documents to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

To convert the project documentation files to PDF format:

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, proceed to click `Save` to save a copy of the file in PDF format. For the best result, use the settings indicated in the screenshot below.

*Menu below will appear after step 3*

.Saving documentation as PDF files in Chrome
image::chrome_save_as_pdf.png[width="300"]

[[Testing]]
== Testing

Testing is very important as it allows us to find application defects that were made during development, and it should be done constantly. It can be expensive if software testing is done only in the later stages of development, as a bug may affect different components of the project.

=== Types of Tests

There are two types of tests that we can run during the development of the project:

.  *GUI Tests* - These are tests involving the GUI. They include:
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components of the software. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include:
..  _Unit tests_ that target the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that check the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  _Hybrids of unit and integration tests_ that check multiple code units as well as how they are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Running Tests

There are three ways to run tests.

*Method 1: Using Gradle (headless)*

* Open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`).

[NOTE]
GUI tests can be run in _headless_ mode due to the https://github.com/TestFX/TestFX[TestFX] library. GUI tests do not show up on the screen in headless mode, which allows you to work on other matters while tests are running.

[NOTE]
Using Gradle (headless) is the most reliable way to run tests. Other testing methods may fail some GUI tests due to platform/resolution-specific idiosyncrasies.

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`).

*Method 3: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`.
* To run a subset of tests, right-click on a test package or a test class, and choose `Run 'Tests in '<test package or test class>''`.


=== Test Troubleshooting
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

////
== Dev Ops

Dev Ops is a software engineering culture and practice that aims at unifying software development (Dev) and software operations (Ops).
Dev Ops advocates automation and monitoring at all steps of software construction. This section illustrates how we adopt this practice in developing CelebManager.
////

=== Build Automation

Please use Gradle for build automation. +
Refer to <<UsingGradle#, UsingGradle.adoc>> for more details.

=== Continuous Integration

Please use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. +
Refer to <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Coverage Reporting

Please use https://coveralls.io/[Coveralls] to track the code coverage of our projects. +
Refer to <<UsingCoveralls#, UsingCoveralls.adoc>> for more details.

=== Documentation Previews

Please use https://www.netlify.com/[Netlify] to see a preview of how the HTML version of changed asciidoc files will look
like when a pull request is merged. +
Please refer to <<UsingNetlify#, UsingNetlify.adoc>> for more details.

=== Application Release

To do the following steps to create a new release, you can:

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number, e.g. `v0.1`.
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Dependencies Management

Management of dependencies on third-party libraries is done using Gradle.
There is no need to include those libraries in the repo or download them manually.

[[GetStartedProgramming]]
[appendix]
== Product Scope

The *target user profile*:

* has a need to manage a significant number of contacts
* prefers desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI Apps
* needs to manage several people's (celebrities') schedule
* has a need to link contacts to appointments

*Value proposition*: manage contacts faster than a typical mouse/GUI driven app

=== Feature Contribution

**MAJOR**

*Adding, deleting, editing appointments*: Able to create, delete and edit appointments within the application. (By Muruges)

*Listing appointments* : Able to list appointments within a date range. (By Muruges)

*Showing location on map*: Able to show the location of an appointment using address in maps. (By Damien)

*Showing route on map*: Able to show the rough route used to calculate the distance and time of travel. (By Damien)

*Storing appointments*: Able to parse appointments information from storage, and save new and edited appointment
information into storage. (By Tzer Bin)

*Reminding of appointments*: Able to draft an email template to remind persons associated with the appointment and fill in the addressees' emails automatically. (By Jinyi)


**MINOR**

*Adding attendees and POCs*: Able to add a list of celebrities and a list of Points of Contact to each appointment. (By Muruges)

*Switching between different calendar views*: Able to switch to view appointments on the calendar by day, week, month and year with CLI. (Jinyi)

*Customizing visual themes*: Able to customize visual themes of the application. (By Tzer Bin)

*Removing a tag*: Able to remove a tag from each person with it in the application. (By Jinyi)

*Calculating distance and time of travel between 2 location*: Able to calculate the distance and time required to travel between
two locations. (By Damien)

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="90%",cols="15%,<20%,<30%,<40%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |so that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |user |add a new person |access contacting information of the person from the App

|`* * *` |user |delete a person |remove contacts that I no longer need

|`* * *` |user |find a person by name |locate details of persons without having to go through the entire list

|`* * *` |user |undo a previous command |remove the change made by mistake

|`* * *` |user |redo a previous command |restore the change removed by mistake

|`* * *` |user |have a calendar inside the address book |know the date and day

|`* * *` |user |display appointments on calendar by day, week, and month |check appointments in different time frames

|`* * *` |user |add an appointment to a calendar |schedule different appointments without time clashes

|`* * *` |user |delete an appointment from a calendar |remove appointments that are cancelled

|`* * *` |user |edit an appointment in a calendar |change the information about the appointment when there is a change in plan or arrangement

|`* * *` |user |save appointments |get appointments loaded in the calendar automatically when I re-launch the App

|`* * *` |user |get alerted for upcoming appointments |set my priorities straight

|`* * *` |user |see the location of an appointment in a map |plan for travel

|`* * *` |user |see various landmarks around a specific location in a road map |understand better the roads around the location

|`* * *` |user |see various landmarks around a specific location in a satellite map |see in real time the actual layout of the surrounding

|`* * *` |user |zoom in and out of the map of a location in a map |view the location in different levels of details

|`* * *` |user |see the best route of travel by driving between two locations in a map |plan for the fastest travel

|`* * *` |celebrity manager who chauffeurs celebrities |see the best route of travel by driving between two locations in a map |plan for the shortest travel

|`* * *` |celebrity manager who chauffeurs celebrities |know if two locations can be reached by driving |foresee any problems and plan ahead

|`* * *` |celebrity manager who chauffeurs celebrities |know the estimated distance between two locations by driving |cater enough time for travelling to avoid being late

|`* * *` |celebrity manager who chauffeurs celebrities |know the estimated time of travel between two locations by driving |reduce the time of travel to reach an appointment location

|`* * *` |celebrity manager |have multiple calendars to display appointments for different celebrities |manage multiple celebrities' appointments

|`* *` |user |hide <<private-contact-detail,private contact details>> by default |minimize chance of someone else seeing them by accident

|`* *` |user |change the size of different windows of the App |customise the window sizes

|`* *` |user who contacts different parties involved in an appointment |draft the message about appointment details automatically |save time to draft the email

|`* *` |user who frequently contacts certain people |sort the contacts by contacting frequency |find those people I frequently contact easily

|`* *` |user |change the colour scheme of the App |choose my preferred colour scheme

|`* *` |celebrity manager |group celebrities by different talents |find celebrities by talent easily

|`* *` |celebrity manager managing celebrities of the same group|add an appointment to the calendars of these celebrities at the same time |save time

|`*` |user with many international contacts |group contacts by country code |see my contacts from different countries

|`*` |user of previous versions of the App |transfer my contacts to the new version |save the trouble of adding the contacts again

|`*` |user with poor eyesight |the address book to read out the contacts to me |use it more efficiently

|`*` |user |output the contacts to a separate list |have a backup copy of the contacts

|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `CelebManager` and the *Actor* is the `user`, unless specified otherwise)

=== Use case: Delete person

*MSS*

1.  User requests to list persons.
2.  CelebManager shows a list of persons.
3.  User requests to delete a specific person in the list.
4.  CelebManager deletes the person.

+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. CelebManager shows an error message.
+
Use case resumes at step 2.

=== Use case: Undo

*MSS*

1.  User requests to undo.
2.  CelebManager undoes the latest executed command that mutates the data.

+
Use case ends.

*Extensions*

[none]
* 2a. There is no executed command that mutates the data.
+
[none]
** 2a1. CelebManager shows an error message.
+
Use case ends.

=== Use case: Redo

*MSS*

1.  User requests to redo.
2.  CelebManager redoes the latest executed undo command.

+
Use case ends.

*Extensions*

[none]
* 2a. There is no executed undo command.
+
[none]
** 2a1. CelebManager shows an error message.
+
Use case ends.

=== Use case: Remove tag

*MSS*

1. User requests to remove a tag.
2. CelebManager removes the tag from any person having it.

+
Use case ends.

*Extensions*

[none]
* 1a. The tag does not exist.
+
[none]
** 1a1. CelebManager shows an error message.
+
Use case ends.

=== Use case: Add appointment

*MSS*

1.  User requests to add an appointment.
2.  CelebManager adds the appointment to the currently displayed calendar.

+
Use case ends.

*Extensions*

[none]
* 1a. Appointment to add has incorrect details or format.
+
[none]
** 1a1. CelebManager shows an error message.
+
Use case ends.

* 2a. Appointment to add clashes with existing appointment.
+
[none]
** 2a1. CelebManager shows an error message.
+
Use case ends.

=== Use case: View appointment

*MSS*

1.  User requests to view appointment.
2.  CelebManager shows the appointment's details.

+
Use case ends.

*Extensions*

[none]
* 1a. Appointment to view does not exist.
+
[none]
** 1a1. CelebManager shows an error message.
+
Use case ends.

=== Use case: List appointments

*MSS*

1.  User requests to list appointments from a start date to an end date.
2.  CelebManager shows a list of appointments within the date range (inclusive).

+
Use case ends.

*Extensions*

[none]
* 1a. The dates are invalid or in wrong format.
+
[none]
** 1a1. CelebManager outputs an error message.
+
Use case ends.

[none]
* 2a. There is no appointment to show in the date range.
+
[none]
** 2a1. CelebManager outputs a message that says no appointment in the specified date range.
+
Use case ends.

=== Use case: Delete appointment

*MSS*

1.  User requests to list appointments from a start date to an end date.
2.  CelebManager shows a list of appointments within the date range (inclusive).
3.  User requests to delete a specific appointment in the list.
4.  CelebManager deletes the appointment.
+
Use case ends.

*Extensions*

[none]
* 1a. The dates are invalid or in wrong format.
+
[none]
** 1a1. CelebManager outputs an error message.
+
Use case ends.

[none]
* 2a. There is no appointment to show in the date range.
+
[none]
** 2a1. CelebManager outputs a message that says no appointment in the specified date range.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. CelebManager shows an error message.
+
Use case resumes at step 2.

=== Use case: Edit appointment

*MSS*

1.  User requests to list appointments from a start date to an end date.
2.  CelebManager shows a list of appointments within the date range (inclusive).
3.  User requests to edit a specified appointment.
4.  CelebManager changes appointment details and displays new appointment details to user.
+
Use case ends.

*Extensions*

[none]
* 1a. The dates are invalid or in wrong format.
+
[none]
** 1a1. CelebManager outputs an error message.
+
Use case ends.

[none]
* 2a. There is no appointment to show in the date range.
+
[none]
** 2a1. CelebManager outputs a message that says no appointment in the specified date range.
+
Use case ends.

[none]
* 3a.  The given index is invalid.
+
[none]
** 3a1. CelebManager shows an error message.
+
Use case resumes at step 2.

[none]
* 3b.  Information entered for edit is invalid.
+
[none]
** 3b1. CelebManager shows an error message.
+
Use case resumes at step 2.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 1000 persons without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Should be usable by people with no knowledge about command line input.
.  Should respond to any user command within 10 seconds.
.  Should be backward compatible with data produced by earlier versions of the CelebManager.
.  Should come with automated unit tests and open source code.
.  Should favor DOS style commands over Unix-style commands.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[private-contact-detail]] Private contact detail::
A contact detail that is not meant to be shared with others

[[celebcalendar]] Celeb calendar::
A calendar that contains all appointments a celebrity managed by the user has

[[calendar-view]] Calendar view::
The way in which appointments are displayed in calendar +
[TIP]
CelebManager currently supports displaying by day, week, month and year.

[[appointment]] Appointment::
A meeting between contacts at a specific time, date and location +
An appointment has a specific name

[[attendees]] Attendees::
A list of contacts who are attending an appointment

[[points-of-contacts]] Points of Contacts::
A list of contacts involved in an appointment but not attending it

[[blacklist]] Blacklist::
A list of contacts which should be marked for being untrustworthy or unacceptable

[[UI]] User Interface::
The Design and looks of the software

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the App manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch
This section includes instructions to test the launch and re-launch of the App. +
For each subsequent launch, window size and location should be the same as the settings before closing the App for previous launch.

. Initial launch

.. Download the jar file
.. Copy into an empty folder
.. Double-click the jar file +
   _Expected: CelebManager shows the GUI with a set of sample contacts._
[NOTE]
    The window size may not be optimum.
.. Resize the window to an optimum size
.. Move the window to a different location
.. Close the window

. Subsequent launch
.. Re-launch the App by double-clicking the jar file +
   _Expected: The most recent window size and location are retained._

=== Deleting a person
This section includes instructions to test the delete command of the application.
[NOTE]
Prerequisites: List all persons using the `list` command. Multiple persons in the list.

.. Type `delete 1` in command box and press enter +
   _Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated._
.. Type `delete 0` in command box and press enter +
   _Expected: No person is deleted. Error details shown in the status message. Status bar remains the same._
.. Type other incorrect delete command such as `delete`, `delete x` (where x is larger than the list size) in command box and press enter +
   _Expected: Similar to previous._

////
=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_
////
